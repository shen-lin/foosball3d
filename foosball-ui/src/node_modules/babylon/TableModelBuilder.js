import BABYLON, { Vector3 } from "babylonjs";
import marble from "resources/material/marble_1.jpg";
import gold from "resources/material/gold.jpg";
import gold2 from "resources/material/gold_2.jpg";
import gold3 from "resources/material/gold_3.jpg";

class TableModelBuilder {
  // Full table width and length
  static TABLE_WIDTH = 5;
  static TABLE_LENGTH = 9.3;

  // Space between bars
  static TABLE_BAR_WIDTH = 4;
  static TABLE_BAR_LENGTH = 8.3;

  static BAR_Y = 200;
  static BAR_WIDTH = 0.7;
  static BAR_HEIGHT = 3;

  static CROSSBAR_Y =
    TableModelBuilder.BAR_Y - TableModelBuilder.BAR_HEIGHT / 4;
  static CROSSBAR_DIAMETER = 0.2;
  static CROSSBAR_LENGTH = TableModelBuilder.TABLE_BAR_WIDTH;

  static SUPPORT_Y = TableModelBuilder.BAR_Y - TableModelBuilder.BAR_HEIGHT / 2;
  static SUPPORT_HEIGHT = 0.08;
  static SUPPORT_DIAMETER = TableModelBuilder.BAR_WIDTH * 0.85;
  static SUPPORT_SIDES = 6;

  static FIELD_LENGTH = 7.8;
  static FIELD_WIDTH = 4.6;
  static BASEBOARD_Y =
    TableModelBuilder.BAR_Y + TableModelBuilder.BAR_HEIGHT / 2;

  static GOAL_PANEL_Y =
    TableModelBuilder.BAR_Y + TableModelBuilder.BAR_HEIGHT / 2;
  static GOAL_PANEL_WIDTH =
    TableModelBuilder.TABLE_BAR_WIDTH + TableModelBuilder.BAR_WIDTH;
  static GOAL_PANEL_HEIGHT = 2.2;

  static SURFACE_Y =
    TableModelBuilder.BASEBOARD_Y + TableModelBuilder.GOAL_PANEL_HEIGHT / 4;

  static HANDLE_Y = TableModelBuilder.SURFACE_Y + 0.2;
  static HANDLE_DIAMETER = 0.05;
  static HANDLE_LENGTH = TableModelBuilder.TABLE_BAR_WIDTH + 3;

  static build(scene) {
    TableModelBuilder.buildBars(scene);
    TableModelBuilder.buildCrossBars(scene);
    TableModelBuilder.buildSupports(scene);
    TableModelBuilder.buildGoalPanels(scene);
    TableModelBuilder.buildHandles(scene);
    TableModelBuilder.buildSurface(scene);
    // TableModelBuilder.buildBaseBoard(scene);
    TableModelBuilder.buildBall(scene);
  }

  static buildBars(scene) {
    const mat = new BABYLON.StandardMaterial("mat", scene);
    const texture = new BABYLON.Texture(marble, scene);
    mat.diffuseTexture = texture;

    const bar1 = TableModelBuilder.buildBar(scene, "bar1", mat);
    const bar2 = TableModelBuilder.buildBar(scene, "bar2", mat);
    const bar3 = TableModelBuilder.buildBar(scene, "bar3", mat);
    const bar4 = TableModelBuilder.buildBar(scene, "bar4", mat);

    bar1.position.x = -(TableModelBuilder.TABLE_BAR_LENGTH / 2);
    bar1.position.y = TableModelBuilder.BAR_Y;
    bar1.position.z = -(TableModelBuilder.TABLE_BAR_WIDTH / 2);
    bar2.position.x = TableModelBuilder.TABLE_BAR_LENGTH / 2;
    bar2.position.y = TableModelBuilder.BAR_Y;
    bar2.position.z = -(TableModelBuilder.TABLE_BAR_WIDTH / 2);
    bar3.position.x = TableModelBuilder.TABLE_BAR_LENGTH / 2;
    bar3.position.y = TableModelBuilder.BAR_Y;
    bar3.position.z = TableModelBuilder.TABLE_BAR_WIDTH / 2;
    bar4.position.x = -(TableModelBuilder.TABLE_BAR_LENGTH / 2);
    bar4.position.y = TableModelBuilder.BAR_Y;
    bar4.position.z = TableModelBuilder.TABLE_BAR_WIDTH / 2;
  }

  static buildBar(scene, id, mat) {
    const bar = BABYLON.MeshBuilder.CreateBox(
      id,
      {
        height: TableModelBuilder.BAR_HEIGHT,
        size: TableModelBuilder.BAR_WIDTH
      },
      scene
    );
    bar.material = mat;
    return bar;
  }

  static buildCrossBars(scene) {
    const mat = new BABYLON.StandardMaterial("mat", scene);
    const texture = new BABYLON.Texture(gold3, scene);
    mat.diffuseTexture = texture;

    const crossBar1 = TableModelBuilder.buildCrossBar(scene, "crossBar1", mat);
    const crossBar2 = TableModelBuilder.buildCrossBar(scene, "crossBar2", mat);

    crossBar1.position.x = -(TableModelBuilder.TABLE_BAR_LENGTH / 2);
    crossBar1.position.y = TableModelBuilder.CROSSBAR_Y;
    crossBar1.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);

    crossBar2.position.x = TableModelBuilder.TABLE_BAR_LENGTH / 2;
    crossBar2.position.y = TableModelBuilder.CROSSBAR_Y;
    crossBar2.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);
  }

  static buildCrossBar(scene, id, mat) {
    const crossBar = BABYLON.MeshBuilder.CreateCylinder(
      id,
      {
        tessellation: 36,
        diameter: TableModelBuilder.CROSSBAR_DIAMETER,
        height: TableModelBuilder.CROSSBAR_LENGTH
      },
      scene
    );
    crossBar.material = mat;
    return crossBar;
  }

  static buildSupports(scene) {
    const mat = new BABYLON.StandardMaterial("mat", scene);
    const texture = new BABYLON.Texture(gold3, scene);
    mat.diffuseTexture = texture;

    const suppor1 = TableModelBuilder.buildSupport(scene, "support1", mat);
    const suppor2 = TableModelBuilder.buildSupport(scene, "support2", mat);
    const suppor3 = TableModelBuilder.buildSupport(scene, "support3", mat);
    const suppor4 = TableModelBuilder.buildSupport(scene, "support4", mat);

    suppor1.position.x = -(TableModelBuilder.TABLE_BAR_LENGTH / 2);
    suppor1.position.y = TableModelBuilder.SUPPORT_Y;
    suppor1.position.z = -(TableModelBuilder.TABLE_BAR_WIDTH / 2);
    suppor2.position.x = TableModelBuilder.TABLE_BAR_LENGTH / 2;
    suppor2.position.y = TableModelBuilder.SUPPORT_Y;
    suppor2.position.z = -(TableModelBuilder.TABLE_BAR_WIDTH / 2);
    suppor3.position.x = TableModelBuilder.TABLE_BAR_LENGTH / 2;
    suppor3.position.y = TableModelBuilder.SUPPORT_Y;
    suppor3.position.z = TableModelBuilder.TABLE_BAR_WIDTH / 2;
    suppor4.position.x = -(TableModelBuilder.TABLE_BAR_LENGTH / 2);
    suppor4.position.y = TableModelBuilder.SUPPORT_Y;
    suppor4.position.z = TableModelBuilder.TABLE_BAR_WIDTH / 2;
  }

  static buildSupport(scene, id, mat) {
    const support = BABYLON.MeshBuilder.CreateCylinder(
      id,
      {
        tessellation: TableModelBuilder.SUPPORT_SIDES,
        diameter: TableModelBuilder.SUPPORT_DIAMETER,
        height: TableModelBuilder.SUPPORT_HEIGHT
      },
      scene
    );

    support.material = mat;
    return support;
  }

  static buildGoalPanels(scene) {
    const mat = new BABYLON.StandardMaterial("mat", scene);
    const texture = new BABYLON.Texture(marble, scene);
    mat.diffuseTexture = texture;

    let gaolPanel1 = TableModelBuilder.buildGoalPanel(
      scene,
      "goalPanel1",
      TableModelBuilder.GOAL_PANEL_WIDTH,
      TableModelBuilder.GOAL_PANEL_HEIGHT
    );
    let gaolPanel2 = TableModelBuilder.buildGoalPanel(
      scene,
      "goalPanel2",
      TableModelBuilder.GOAL_PANEL_WIDTH,
      TableModelBuilder.GOAL_PANEL_HEIGHT
    );

    gaolPanel1.position.x = -TableModelBuilder.TABLE_LENGTH / 2;
    gaolPanel1.position.y = TableModelBuilder.GOAL_PANEL_Y;
    gaolPanel1.rotate(BABYLON.Axis.Z, Math.PI / 2, BABYLON.Space.WORLD);
    gaolPanel1.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);
    gaolPanel1.material = mat;

    gaolPanel2.material = mat;
    gaolPanel2.position.x = TableModelBuilder.TABLE_LENGTH / 2;
    gaolPanel2.position.y = TableModelBuilder.GOAL_PANEL_Y;
    gaolPanel2.rotate(BABYLON.Axis.Z, Math.PI / 2, BABYLON.Space.WORLD);
    gaolPanel2.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);
  }

  static buildGoalPanel(scene, id, width, height) {
    let shape = [
      new BABYLON.Vector3(-width / 2, 0, height / 2),
      new BABYLON.Vector3(width / 2, 0, height / 2),
      new BABYLON.Vector3(width / 2, 0, -height / 2),
      new BABYLON.Vector3(-width / 2, 0, -height / 2)
    ];

    var holes = [];
    // holes[0] = [
    //   new BABYLON.Vector3(1, 0, -1),
    //   new BABYLON.Vector3(1.5, 0, 0),
    //   new BABYLON.Vector3(1.4, 0, 1),
    //   new BABYLON.Vector3(0.5, 0, 1.5)
    // ];
    // holes[1] = [
    //   new BABYLON.Vector3(0, 0, -2),
    //   new BABYLON.Vector3(0.5, 0, -1),
    //   new BABYLON.Vector3(0.4, 0, 0),
    //   new BABYLON.Vector3(-1.5, 0, 0.5)
    // ];

    let polygon = BABYLON.MeshBuilder.ExtrudePolygon(
      id,
      {
        shape: shape,
        holes: holes,
        depth: 0,
        sideOrientation: BABYLON.Mesh.DOUBLESIDE
      },
      scene
    );

    return polygon;
  }

  static buildHandles(scene) {
    const mat = new BABYLON.StandardMaterial("mat", scene);
    const texture = new BABYLON.Texture(marble, scene);
    mat.diffuseTexture = texture;

    const crossBar1 = TableModelBuilder.buildHandle(scene, "handle1", mat);
    const crossBar2 = TableModelBuilder.buildHandle(scene, "handle2", mat);
    const crossBar3 = TableModelBuilder.buildHandle(scene, "handle3", mat);
    const crossBar4 = TableModelBuilder.buildHandle(scene, "handle4", mat);
    const crossBar5 = TableModelBuilder.buildHandle(scene, "handle5", mat);
    const crossBar6 = TableModelBuilder.buildHandle(scene, "handle6", mat);
    const crossBar7 = TableModelBuilder.buildHandle(scene, "handle7", mat);
    const crossBar8 = TableModelBuilder.buildHandle(scene, "handle8", mat);

    const startPositionXOffset = TableModelBuilder.TABLE_BAR_LENGTH / 2 / 8;
    const positionXGap = TableModelBuilder.TABLE_BAR_LENGTH / 2 / 4;

    crossBar1.position.x =
      TableModelBuilder.TABLE_BAR_LENGTH / 2 - startPositionXOffset;
    crossBar1.position.y = TableModelBuilder.HANDLE_Y;
    crossBar1.position.z = 0.6;
    crossBar1.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);

    crossBar2.position.x = crossBar1.position.x - positionXGap;
    crossBar2.position.y = TableModelBuilder.HANDLE_Y;
    crossBar2.position.z = 0.6;
    crossBar2.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);

    crossBar3.position.x = crossBar2.position.x - positionXGap;
    crossBar3.position.y = TableModelBuilder.HANDLE_Y;
    crossBar3.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);

    crossBar4.position.x = crossBar3.position.x - positionXGap;
    crossBar4.position.y = TableModelBuilder.HANDLE_Y;
    crossBar4.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);

    crossBar5.position.x = crossBar4.position.x - positionXGap;
    crossBar5.position.y = TableModelBuilder.HANDLE_Y;
    crossBar5.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);

    crossBar6.position.x = crossBar5.position.x - positionXGap;
    crossBar6.position.y = TableModelBuilder.HANDLE_Y;
    crossBar6.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);

    crossBar7.position.x = crossBar6.position.x - positionXGap;
    crossBar7.position.y = TableModelBuilder.HANDLE_Y;
    crossBar7.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);

    crossBar8.position.x = crossBar7.position.x - positionXGap;
    crossBar8.position.y = TableModelBuilder.HANDLE_Y;
    crossBar8.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);

    // Add players
    const playerMat = new BABYLON.StandardMaterial("mat", scene);
    const playerTexture = new BABYLON.Texture(gold3, scene);
    playerMat.diffuseTexture = playerTexture;

    const handle1Player1 = TableModelBuilder.buildPlayer(
      scene,
      "handle1-player1",
      playerMat
    );
    handle1Player1.position.y = TableModelBuilder.HANDLE_Y;
    handle1Player1.position.x = crossBar1.position.x;
    handle1Player1.position.z = crossBar1.position.z;
    handle1Player1.setParent(crossBar1);
  }

  static buildHandle(scene, id, mat) {
    const crossBar = BABYLON.MeshBuilder.CreateCylinder(
      id,
      {
        tessellation: 36,
        diameter: TableModelBuilder.HANDLE_DIAMETER,
        height: TableModelBuilder.HANDLE_LENGTH
      },
      scene
    );
    crossBar.material = mat;
    return crossBar;
  }

  static buildPlayer(scene, id, mat) {
    var player = BABYLON.MeshBuilder.CreateBox(
      id,
      { height: 0.5, width: 0.2, depth: 0.2 },
      scene
    );
    player.material = mat;
    return player;
  }

  static buildSurface(scene) {
    const mat = new BABYLON.StandardMaterial("mat", scene);
    const texture = new BABYLON.Texture(marble, scene);
    mat.diffuseTexture = texture;
    const surfaceBoard = BABYLON.MeshBuilder.CreateGround(
      "surface",
      {
        height: TableModelBuilder.FIELD_LENGTH,
        width: TableModelBuilder.FIELD_WIDTH
      },
      scene
    );

    // const surfaceBoard = BABYLON.Mesh.CreateGround(
    //   "surface",
    //   6,
    //   3,
    //   2,
    //   scene
    // );

    surfaceBoard.position.y = TableModelBuilder.SURFACE_Y;
    // surfaceBoard.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);
    surfaceBoard.rotate(BABYLON.Axis.Y, Math.PI / 2, BABYLON.Space.WORLD);
    surfaceBoard.material = mat;
  }

  static buildBaseBoard(scene) {
    const mat = new BABYLON.StandardMaterial("mat", scene);
    const texture = new BABYLON.Texture(marble, scene);
    mat.diffuseTexture = texture;

    const baseBoard = BABYLON.MeshBuilder.CreatePlane(
      "baseBoard",
      {
        height: TableModelBuilder.FIELD_LENGTH,
        width: TableModelBuilder.FIELD_WIDTH
      },
      scene
    );

    baseBoard.position.y = TableModelBuilder.BASEBOARD_Y;
    baseBoard.rotate(BABYLON.Axis.X, Math.PI / 2, BABYLON.Space.WORLD);
    baseBoard.rotate(BABYLON.Axis.Y, Math.PI / 2, BABYLON.Space.WORLD);

    baseBoard.material = mat;
  }

  static buildBall(scene) {
    const mat = new BABYLON.StandardMaterial("mat", scene);
    const texture = new BABYLON.Texture(gold3, scene);
    mat.diffuseTexture = texture;

    const ball = BABYLON.MeshBuilder.CreateSphere(
      "ball",
      { diameter: 1, segments: 16 },
      scene
    );
    ball.material = mat;
    ball.position.y = TableModelBuilder.SURFACE_Y + 4;
    ball.scaling.x = .23;
    ball.scaling.y = .23;
    ball.scaling.z = .23;
  }
}

export default TableModelBuilder;
