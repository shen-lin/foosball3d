import React, { Component } from "react";
import "./Game.css";
import { connect } from "react-redux";
import { BrowserRouter as Router, Route, Link } from "react-router-dom";
import { Scene, registerHandler, removeHandler } from "react-babylonjs";
import BABYLON from "babylonjs";
import "babylonjs-materials";

import SceneBuilder from "babylon/SceneBuilder";
import TableModelBuilder from "babylon/TableModelBuilder";

import GameControl from "ui/component/GameControl";

class Game extends Component {
  constructor(props) {
    super(props);

    this.debugOn = props.debugOn;
    this.debugOff = props.debugOff;
    this.debugEnabled = false;
  }

  toggleDebug() {
    if (this.debugEnabled) {
      this.debugOff();
    } else {
      this.debugOn();
    }
    this.debugEnabled = !this.debugEnabled;
  }

  onMeshPicked(mesh, scene) {
    console.log("Picked mesh", mesh);
  }

  /**
   *
   * @param {SceneEventArgs} eventArgs
   */
  onSceneMount(eventArgs) {
    const { canvas, scene } = eventArgs;
    this.scene = scene;

    const camera = new BABYLON.FreeCamera(
      "camera1",
      new BABYLON.Vector3(5, 208, 10),
      scene
    );
    camera.attachControl(canvas, false);
    camera.setTarget(BABYLON.Vector3.Zero());

    var light = new BABYLON.HemisphericLight(
      "light1",
      new BABYLON.Vector3(0, 1, 0),
      scene
    );
    light.intensity = 0.7;

    var pl = new BABYLON.PointLight("pl", BABYLON.Vector3.Zero(), scene);
    pl.intensity = 0.5;
    pl.position = camera.position;

    this.initScene(eventArgs);

    scene.getEngine().runRenderLoop(() => {
      scene.render();
    });
  }

  initScene(eventArgs) {
    const { canvas, scene } = eventArgs;
    const sceneBuilder = new SceneBuilder(canvas, scene);
    const tableModelBuilder = new TableModelBuilder(canvas, scene);

    sceneBuilder.build();
    tableModelBuilder.build();
  }

  render() {
    return (
      <div className="game">
        <Scene
          onSceneMount={this.onSceneMount.bind(this)}
          onMeshPicked={this.onMeshPicked.bind(this)}
          visible={true}
        />
        <div className="game-control-container game-control-container-left">
          <GameControl />
        </div>
        <div className="game-control-container game-control-container-right">
          <GameControl />
        </div>
      </div>
    );
  }
}

function mapStateToProps(state) {
  const { route } = state;

  return {
    route
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: {
      changeRoute: routeName =>
        dispatch({
          type: "CHANGE_ROUTE",
          routeName
        })
    }
  };
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Game);
