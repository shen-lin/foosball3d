import React, { Component } from "react";
import "./Game.css";
import { connect } from "react-redux";
import { BrowserRouter as Router, Route, Link } from "react-router-dom";
import { Scene } from "react-babylonjs";
import BABYLON from "babylonjs";
import "babylonjs-materials";

import SceneBuilder from "babylon/SceneBuilder";
import TableModelBuilder from "babylon/TableModelBuilder";
import CollisionBuilder from "babylon/CollisionBuilder";
import GameControl from "ui/component/GameControl";

import PhysicsEngine from "physics/PhysicsEngine";

class Game extends Component {
  constructor(props) {
    super(props);

    this.debugOn = props.debugOn;
    this.debugOff = props.debugOff;
    this.debugEnabled = false;
    this.physicsEngine;
  }

  toggleDebug() {
    if (this.debugEnabled) {
      this.debugOff();
    } else {
      this.debugOn();
    }
    this.debugEnabled = !this.debugEnabled;
  }

  onMeshPicked(mesh, scene) {
    console.log("Picked mesh", mesh);
  }

  /**
   *
   * @param {SceneEventArgs} eventArgs
   */
  onSceneMount(eventArgs) {
    const { canvas, scene } = eventArgs;

    const camera = new BABYLON.FreeCamera(
      "camera1",
      new BABYLON.Vector3(5, 208, 10),
      scene
    );
    camera.attachControl(canvas, false);
    camera.setTarget(BABYLON.Vector3.Zero());

    var light = new BABYLON.HemisphericLight(
      "light1",
      new BABYLON.Vector3(0, 1, 0),
      scene
    );
    light.intensity = 0.7;

    var pl = new BABYLON.PointLight("pl", BABYLON.Vector3.Zero(), scene);
    pl.intensity = 0.5;
    pl.position = camera.position;

    this.initScene(eventArgs);

    scene.getEngine().runRenderLoop(() => {
      scene.render();
    });
  }

  initScene(eventArgs) {
    const { canvas, scene } = eventArgs;
    const gravityVector = new BABYLON.Vector3(0, -9.81, 0);
    const physicsPlugin = new BABYLON.CannonJSPlugin();
    scene.enablePhysics(gravityVector, physicsPlugin);

    SceneBuilder.build(scene);
    TableModelBuilder.build(scene);
    CollisionBuilder.addCollisions(scene);

    window.babylon = {
      canvas: canvas,
      scene: scene,
      setTopDownCameraView: function() {
        window.babylon.scene.cameras[0].position.y = 215;
        window.babylon.scene.cameras[0].position.x = 0;
        window.babylon.scene.cameras[0].position.z = 0; 
      },
      setHorizontalCameraView: function() {
        window.babylon.scene.cameras[0].position.y = 203;
        window.babylon.scene.cameras[0].position.x = 0;
        window.babylon.scene.cameras[0].position.z = 10; 
      },
    };

    this.physicsEngine = new PhysicsEngine();
    this.physicsEngine.startPhysicsEngine();
  }

  render() {
    return (
      <div className="game">
        <Scene
          onSceneMount={this.onSceneMount.bind(this)}
          onMeshPicked={this.onMeshPicked.bind(this)}
          visible={true}
        />
        <div className="game-control-container game-control-container-left">
          <GameControl gameControl="leftControl" />
        </div>
        <div className="game-control-container game-control-container-right">
          <GameControl gameControl="rightControl" />
        </div>
      </div>
    );
  }
}

function mapStateToProps(state) {
  const { route, gamestate } = state;

  return {
    route,
    gamestate
  };
}

function mapDispatchToProps(dispatch) {
  return {
    actions: {
      changeRoute: routeName =>
        dispatch({
          type: "CHANGE_ROUTE",
          routeName
        })
    }
  };
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(Game);
